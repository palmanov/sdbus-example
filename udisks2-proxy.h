
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__udisks2_proxy_h__proxy__H__
#define __sdbuscpp__udisks2_proxy_h__proxy__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Manager_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Manager";

protected:
    Manager_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Manager_proxy() = default;

public:
    sdbus::Struct<bool, std::string> CanFormat(const std::string& type)
    {
        sdbus::Struct<bool, std::string> result;
        proxy_.callMethod("CanFormat").onInterface(INTERFACE_NAME).withArguments(type).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<bool, uint64_t, std::string> CanResize(const std::string& type)
    {
        sdbus::Struct<bool, uint64_t, std::string> result;
        proxy_.callMethod("CanResize").onInterface(INTERFACE_NAME).withArguments(type).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<bool, std::string> CanCheck(const std::string& type)
    {
        sdbus::Struct<bool, std::string> result;
        proxy_.callMethod("CanCheck").onInterface(INTERFACE_NAME).withArguments(type).storeResultsTo(result);
        return result;
    }

    sdbus::Struct<bool, std::string> CanRepair(const std::string& type)
    {
        sdbus::Struct<bool, std::string> result;
        proxy_.callMethod("CanRepair").onInterface(INTERFACE_NAME).withArguments(type).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath LoopSetup(const sdbus::UnixFd& fd, const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::ObjectPath result;
        proxy_.callMethod("LoopSetup").onInterface(INTERFACE_NAME).withArguments(fd, options).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath MDRaidCreate(const std::vector<sdbus::ObjectPath>& blocks, const std::string& level, const std::string& name, const uint64_t& chunk, const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::ObjectPath result;
        proxy_.callMethod("MDRaidCreate").onInterface(INTERFACE_NAME).withArguments(blocks, level, name, chunk, options).storeResultsTo(result);
        return result;
    }

    void EnableModules(const bool& enable)
    {
        proxy_.callMethod("EnableModules").onInterface(INTERFACE_NAME).withArguments(enable);
    }

    void EnableModule(const std::string& name, const bool& enable)
    {
        proxy_.callMethod("EnableModule").onInterface(INTERFACE_NAME).withArguments(name, enable);
    }

    std::vector<sdbus::ObjectPath> GetBlockDevices(const std::map<std::string, sdbus::Variant>& options)
    {
        std::vector<sdbus::ObjectPath> result;
        proxy_.callMethod("GetBlockDevices").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    std::vector<sdbus::ObjectPath> ResolveDevice(const std::map<std::string, sdbus::Variant>& devspec, const std::map<std::string, sdbus::Variant>& options)
    {
        std::vector<sdbus::ObjectPath> result;
        proxy_.callMethod("ResolveDevice").onInterface(INTERFACE_NAME).withArguments(devspec, options).storeResultsTo(result);
        return result;
    }

public:
    std::string Version()
    {
        return proxy_.getProperty("Version").onInterface(INTERFACE_NAME);
    }

    std::vector<std::string> SupportedFilesystems()
    {
        return proxy_.getProperty("SupportedFilesystems").onInterface(INTERFACE_NAME);
    }

    std::vector<std::string> SupportedEncryptionTypes()
    {
        return proxy_.getProperty("SupportedEncryptionTypes").onInterface(INTERFACE_NAME);
    }

    std::string DefaultEncryptionType()
    {
        return proxy_.getProperty("DefaultEncryptionType").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace Manager {

class NVMe_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Manager.NVMe";

protected:
    NVMe_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~NVMe_proxy() = default;

public:
    void SetHostNQN(const std::vector<uint8_t>& hostnqn, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetHostNQN").onInterface(INTERFACE_NAME).withArguments(hostnqn, options);
    }

    void SetHostID(const std::vector<uint8_t>& hostid, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetHostID").onInterface(INTERFACE_NAME).withArguments(hostid, options);
    }

    sdbus::ObjectPath Connect(const std::vector<uint8_t>& subsysnqn, const std::string& transport, const std::string& transport_addr, const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::ObjectPath result;
        proxy_.callMethod("Connect").onInterface(INTERFACE_NAME).withArguments(subsysnqn, transport, transport_addr, options).storeResultsTo(result);
        return result;
    }

public:
    std::vector<uint8_t> HostNQN()
    {
        return proxy_.getProperty("HostNQN").onInterface(INTERFACE_NAME);
    }

    std::vector<uint8_t> HostID()
    {
        return proxy_.getProperty("HostID").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Drive_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Drive";

protected:
    Drive_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Drive_proxy() = default;

public:
    void Eject(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Eject").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void SetConfiguration(const std::map<std::string, sdbus::Variant>& value, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetConfiguration").onInterface(INTERFACE_NAME).withArguments(value, options);
    }

    void PowerOff(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("PowerOff").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    std::string Vendor()
    {
        return proxy_.getProperty("Vendor").onInterface(INTERFACE_NAME);
    }

    std::string Model()
    {
        return proxy_.getProperty("Model").onInterface(INTERFACE_NAME);
    }

    std::string Revision()
    {
        return proxy_.getProperty("Revision").onInterface(INTERFACE_NAME);
    }

    std::string Serial()
    {
        return proxy_.getProperty("Serial").onInterface(INTERFACE_NAME);
    }

    std::string WWN()
    {
        return proxy_.getProperty("WWN").onInterface(INTERFACE_NAME);
    }

    std::string Id()
    {
        return proxy_.getProperty("Id").onInterface(INTERFACE_NAME);
    }

    std::map<std::string, sdbus::Variant> Configuration()
    {
        return proxy_.getProperty("Configuration").onInterface(INTERFACE_NAME);
    }

    std::string Media()
    {
        return proxy_.getProperty("Media").onInterface(INTERFACE_NAME);
    }

    std::vector<std::string> MediaCompatibility()
    {
        return proxy_.getProperty("MediaCompatibility").onInterface(INTERFACE_NAME);
    }

    bool MediaRemovable()
    {
        return proxy_.getProperty("MediaRemovable").onInterface(INTERFACE_NAME);
    }

    bool MediaAvailable()
    {
        return proxy_.getProperty("MediaAvailable").onInterface(INTERFACE_NAME);
    }

    bool MediaChangeDetected()
    {
        return proxy_.getProperty("MediaChangeDetected").onInterface(INTERFACE_NAME);
    }

    uint64_t Size()
    {
        return proxy_.getProperty("Size").onInterface(INTERFACE_NAME);
    }

    uint64_t TimeDetected()
    {
        return proxy_.getProperty("TimeDetected").onInterface(INTERFACE_NAME);
    }

    uint64_t TimeMediaDetected()
    {
        return proxy_.getProperty("TimeMediaDetected").onInterface(INTERFACE_NAME);
    }

    bool Optical()
    {
        return proxy_.getProperty("Optical").onInterface(INTERFACE_NAME);
    }

    bool OpticalBlank()
    {
        return proxy_.getProperty("OpticalBlank").onInterface(INTERFACE_NAME);
    }

    uint32_t OpticalNumTracks()
    {
        return proxy_.getProperty("OpticalNumTracks").onInterface(INTERFACE_NAME);
    }

    uint32_t OpticalNumAudioTracks()
    {
        return proxy_.getProperty("OpticalNumAudioTracks").onInterface(INTERFACE_NAME);
    }

    uint32_t OpticalNumDataTracks()
    {
        return proxy_.getProperty("OpticalNumDataTracks").onInterface(INTERFACE_NAME);
    }

    uint32_t OpticalNumSessions()
    {
        return proxy_.getProperty("OpticalNumSessions").onInterface(INTERFACE_NAME);
    }

    int32_t RotationRate()
    {
        return proxy_.getProperty("RotationRate").onInterface(INTERFACE_NAME);
    }

    std::string ConnectionBus()
    {
        return proxy_.getProperty("ConnectionBus").onInterface(INTERFACE_NAME);
    }

    std::string Seat()
    {
        return proxy_.getProperty("Seat").onInterface(INTERFACE_NAME);
    }

    bool Removable()
    {
        return proxy_.getProperty("Removable").onInterface(INTERFACE_NAME);
    }

    bool Ejectable()
    {
        return proxy_.getProperty("Ejectable").onInterface(INTERFACE_NAME);
    }

    std::string SortKey()
    {
        return proxy_.getProperty("SortKey").onInterface(INTERFACE_NAME);
    }

    bool CanPowerOff()
    {
        return proxy_.getProperty("CanPowerOff").onInterface(INTERFACE_NAME);
    }

    std::string SiblingId()
    {
        return proxy_.getProperty("SiblingId").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace Drive {

class Ata_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Drive.Ata";

protected:
    Ata_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Ata_proxy() = default;

public:
    void SmartUpdate(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SmartUpdate").onInterface(INTERFACE_NAME).withArguments(options);
    }

    std::vector<sdbus::Struct<uint8_t, std::string, uint16_t, int32_t, int32_t, int32_t, int64_t, int32_t, std::map<std::string, sdbus::Variant>>> SmartGetAttributes(const std::map<std::string, sdbus::Variant>& options)
    {
        std::vector<sdbus::Struct<uint8_t, std::string, uint16_t, int32_t, int32_t, int32_t, int64_t, int32_t, std::map<std::string, sdbus::Variant>>> result;
        proxy_.callMethod("SmartGetAttributes").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    void SmartSelftestStart(const std::string& type, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SmartSelftestStart").onInterface(INTERFACE_NAME).withArguments(type, options);
    }

    void SmartSelftestAbort(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SmartSelftestAbort").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void SmartSetEnabled(const bool& value, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SmartSetEnabled").onInterface(INTERFACE_NAME).withArguments(value, options);
    }

    uint8_t PmGetState(const std::map<std::string, sdbus::Variant>& options)
    {
        uint8_t result;
        proxy_.callMethod("PmGetState").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    void PmStandby(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("PmStandby").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void PmWakeup(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("PmWakeup").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void SecurityEraseUnit(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SecurityEraseUnit").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    bool SmartSupported()
    {
        return proxy_.getProperty("SmartSupported").onInterface(INTERFACE_NAME);
    }

    bool SmartEnabled()
    {
        return proxy_.getProperty("SmartEnabled").onInterface(INTERFACE_NAME);
    }

    uint64_t SmartUpdated()
    {
        return proxy_.getProperty("SmartUpdated").onInterface(INTERFACE_NAME);
    }

    bool SmartFailing()
    {
        return proxy_.getProperty("SmartFailing").onInterface(INTERFACE_NAME);
    }

    uint64_t SmartPowerOnSeconds()
    {
        return proxy_.getProperty("SmartPowerOnSeconds").onInterface(INTERFACE_NAME);
    }

    double SmartTemperature()
    {
        return proxy_.getProperty("SmartTemperature").onInterface(INTERFACE_NAME);
    }

    int32_t SmartNumAttributesFailing()
    {
        return proxy_.getProperty("SmartNumAttributesFailing").onInterface(INTERFACE_NAME);
    }

    int32_t SmartNumAttributesFailedInThePast()
    {
        return proxy_.getProperty("SmartNumAttributesFailedInThePast").onInterface(INTERFACE_NAME);
    }

    int64_t SmartNumBadSectors()
    {
        return proxy_.getProperty("SmartNumBadSectors").onInterface(INTERFACE_NAME);
    }

    std::string SmartSelftestStatus()
    {
        return proxy_.getProperty("SmartSelftestStatus").onInterface(INTERFACE_NAME);
    }

    int32_t SmartSelftestPercentRemaining()
    {
        return proxy_.getProperty("SmartSelftestPercentRemaining").onInterface(INTERFACE_NAME);
    }

    bool PmSupported()
    {
        return proxy_.getProperty("PmSupported").onInterface(INTERFACE_NAME);
    }

    bool PmEnabled()
    {
        return proxy_.getProperty("PmEnabled").onInterface(INTERFACE_NAME);
    }

    bool ApmSupported()
    {
        return proxy_.getProperty("ApmSupported").onInterface(INTERFACE_NAME);
    }

    bool ApmEnabled()
    {
        return proxy_.getProperty("ApmEnabled").onInterface(INTERFACE_NAME);
    }

    bool AamSupported()
    {
        return proxy_.getProperty("AamSupported").onInterface(INTERFACE_NAME);
    }

    bool AamEnabled()
    {
        return proxy_.getProperty("AamEnabled").onInterface(INTERFACE_NAME);
    }

    int32_t AamVendorRecommendedValue()
    {
        return proxy_.getProperty("AamVendorRecommendedValue").onInterface(INTERFACE_NAME);
    }

    bool WriteCacheSupported()
    {
        return proxy_.getProperty("WriteCacheSupported").onInterface(INTERFACE_NAME);
    }

    bool WriteCacheEnabled()
    {
        return proxy_.getProperty("WriteCacheEnabled").onInterface(INTERFACE_NAME);
    }

    bool ReadLookaheadSupported()
    {
        return proxy_.getProperty("ReadLookaheadSupported").onInterface(INTERFACE_NAME);
    }

    bool ReadLookaheadEnabled()
    {
        return proxy_.getProperty("ReadLookaheadEnabled").onInterface(INTERFACE_NAME);
    }

    int32_t SecurityEraseUnitMinutes()
    {
        return proxy_.getProperty("SecurityEraseUnitMinutes").onInterface(INTERFACE_NAME);
    }

    int32_t SecurityEnhancedEraseUnitMinutes()
    {
        return proxy_.getProperty("SecurityEnhancedEraseUnitMinutes").onInterface(INTERFACE_NAME);
    }

    bool SecurityFrozen()
    {
        return proxy_.getProperty("SecurityFrozen").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace NVMe {

class Controller_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.NVMe.Controller";

protected:
    Controller_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Controller_proxy() = default;

public:
    void SmartUpdate(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SmartUpdate").onInterface(INTERFACE_NAME).withArguments(options);
    }

    std::map<std::string, sdbus::Variant> SmartGetAttributes(const std::map<std::string, sdbus::Variant>& options)
    {
        std::map<std::string, sdbus::Variant> result;
        proxy_.callMethod("SmartGetAttributes").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    void SmartSelftestStart(const std::string& type, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SmartSelftestStart").onInterface(INTERFACE_NAME).withArguments(type, options);
    }

    void SmartSelftestAbort(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SmartSelftestAbort").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void SanitizeStart(const std::string& action, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SanitizeStart").onInterface(INTERFACE_NAME).withArguments(action, options);
    }

public:
    std::string State()
    {
        return proxy_.getProperty("State").onInterface(INTERFACE_NAME);
    }

    uint16_t ControllerID()
    {
        return proxy_.getProperty("ControllerID").onInterface(INTERFACE_NAME);
    }

    std::vector<uint8_t> SubsystemNQN()
    {
        return proxy_.getProperty("SubsystemNQN").onInterface(INTERFACE_NAME);
    }

    std::string FGUID()
    {
        return proxy_.getProperty("FGUID").onInterface(INTERFACE_NAME);
    }

    std::string NVMeRevision()
    {
        return proxy_.getProperty("NVMeRevision").onInterface(INTERFACE_NAME);
    }

    uint64_t UnallocatedCapacity()
    {
        return proxy_.getProperty("UnallocatedCapacity").onInterface(INTERFACE_NAME);
    }

    uint64_t SmartUpdated()
    {
        return proxy_.getProperty("SmartUpdated").onInterface(INTERFACE_NAME);
    }

    std::vector<std::string> SmartCriticalWarning()
    {
        return proxy_.getProperty("SmartCriticalWarning").onInterface(INTERFACE_NAME);
    }

    uint64_t SmartPowerOnHours()
    {
        return proxy_.getProperty("SmartPowerOnHours").onInterface(INTERFACE_NAME);
    }

    uint16_t SmartTemperature()
    {
        return proxy_.getProperty("SmartTemperature").onInterface(INTERFACE_NAME);
    }

    std::string SmartSelftestStatus()
    {
        return proxy_.getProperty("SmartSelftestStatus").onInterface(INTERFACE_NAME);
    }

    int32_t SmartSelftestPercentRemaining()
    {
        return proxy_.getProperty("SmartSelftestPercentRemaining").onInterface(INTERFACE_NAME);
    }

    std::string SanitizeStatus()
    {
        return proxy_.getProperty("SanitizeStatus").onInterface(INTERFACE_NAME);
    }

    int32_t SanitizePercentRemaining()
    {
        return proxy_.getProperty("SanitizePercentRemaining").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace NVMe {

class Namespace_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.NVMe.Namespace";

protected:
    Namespace_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Namespace_proxy() = default;

public:
    void FormatNamespace(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("FormatNamespace").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    uint32_t NSID()
    {
        return proxy_.getProperty("NSID").onInterface(INTERFACE_NAME);
    }

    std::string NGUID()
    {
        return proxy_.getProperty("NGUID").onInterface(INTERFACE_NAME);
    }

    std::string EUI64()
    {
        return proxy_.getProperty("EUI64").onInterface(INTERFACE_NAME);
    }

    std::string UUID()
    {
        return proxy_.getProperty("UUID").onInterface(INTERFACE_NAME);
    }

    std::string WWN()
    {
        return proxy_.getProperty("WWN").onInterface(INTERFACE_NAME);
    }

    std::vector<sdbus::Struct<uint16_t, uint16_t, uint8_t>> LBAFormats()
    {
        return proxy_.getProperty("LBAFormats").onInterface(INTERFACE_NAME);
    }

    sdbus::Struct<uint16_t, uint16_t, uint8_t> FormattedLBASize()
    {
        return proxy_.getProperty("FormattedLBASize").onInterface(INTERFACE_NAME);
    }

    uint64_t NamespaceSize()
    {
        return proxy_.getProperty("NamespaceSize").onInterface(INTERFACE_NAME);
    }

    uint64_t NamespaceCapacity()
    {
        return proxy_.getProperty("NamespaceCapacity").onInterface(INTERFACE_NAME);
    }

    uint64_t NamespaceUtilization()
    {
        return proxy_.getProperty("NamespaceUtilization").onInterface(INTERFACE_NAME);
    }

    int32_t FormatPercentRemaining()
    {
        return proxy_.getProperty("FormatPercentRemaining").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace NVMe {

class Fabrics_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.NVMe.Fabrics";

protected:
    Fabrics_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Fabrics_proxy() = default;

public:
    void Disconnect(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Disconnect").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    std::vector<uint8_t> HostNQN()
    {
        return proxy_.getProperty("HostNQN").onInterface(INTERFACE_NAME);
    }

    std::vector<uint8_t> HostID()
    {
        return proxy_.getProperty("HostID").onInterface(INTERFACE_NAME);
    }

    std::string Transport()
    {
        return proxy_.getProperty("Transport").onInterface(INTERFACE_NAME);
    }

    std::vector<uint8_t> TransportAddress()
    {
        return proxy_.getProperty("TransportAddress").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Block_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Block";

protected:
    Block_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Block_proxy() = default;

public:
    void AddConfigurationItem(const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& item, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("AddConfigurationItem").onInterface(INTERFACE_NAME).withArguments(item, options);
    }

    void RemoveConfigurationItem(const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& item, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("RemoveConfigurationItem").onInterface(INTERFACE_NAME).withArguments(item, options);
    }

    void UpdateConfigurationItem(const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& old_item, const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& new_item, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("UpdateConfigurationItem").onInterface(INTERFACE_NAME).withArguments(old_item, new_item, options);
    }

    std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> GetSecretConfiguration(const std::map<std::string, sdbus::Variant>& options)
    {
        std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> result;
        proxy_.callMethod("GetSecretConfiguration").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    void Format(const std::string& type, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Format").onInterface(INTERFACE_NAME).withArguments(type, options);
    }

    sdbus::UnixFd OpenForBackup(const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::UnixFd result;
        proxy_.callMethod("OpenForBackup").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    sdbus::UnixFd OpenForRestore(const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::UnixFd result;
        proxy_.callMethod("OpenForRestore").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    sdbus::UnixFd OpenForBenchmark(const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::UnixFd result;
        proxy_.callMethod("OpenForBenchmark").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    sdbus::UnixFd OpenDevice(const std::string& mode, const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::UnixFd result;
        proxy_.callMethod("OpenDevice").onInterface(INTERFACE_NAME).withArguments(mode, options).storeResultsTo(result);
        return result;
    }

    void Rescan(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Rescan").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    std::vector<uint8_t> Device()
    {
        return proxy_.getProperty("Device").onInterface(INTERFACE_NAME);
    }

    std::vector<uint8_t> PreferredDevice()
    {
        return proxy_.getProperty("PreferredDevice").onInterface(INTERFACE_NAME);
    }

    std::vector<std::vector<uint8_t>> Symlinks()
    {
        return proxy_.getProperty("Symlinks").onInterface(INTERFACE_NAME);
    }

    uint64_t DeviceNumber()
    {
        return proxy_.getProperty("DeviceNumber").onInterface(INTERFACE_NAME);
    }

    std::string Id()
    {
        return proxy_.getProperty("Id").onInterface(INTERFACE_NAME);
    }

    uint64_t Size()
    {
        return proxy_.getProperty("Size").onInterface(INTERFACE_NAME);
    }

    bool ReadOnly()
    {
        return proxy_.getProperty("ReadOnly").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath Drive()
    {
        return proxy_.getProperty("Drive").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath MDRaid()
    {
        return proxy_.getProperty("MDRaid").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath MDRaidMember()
    {
        return proxy_.getProperty("MDRaidMember").onInterface(INTERFACE_NAME);
    }

    std::string IdUsage()
    {
        return proxy_.getProperty("IdUsage").onInterface(INTERFACE_NAME);
    }

    std::string IdType()
    {
        return proxy_.getProperty("IdType").onInterface(INTERFACE_NAME);
    }

    std::string IdVersion()
    {
        return proxy_.getProperty("IdVersion").onInterface(INTERFACE_NAME);
    }

    std::string IdLabel()
    {
        return proxy_.getProperty("IdLabel").onInterface(INTERFACE_NAME);
    }

    std::string IdUUID()
    {
        return proxy_.getProperty("IdUUID").onInterface(INTERFACE_NAME);
    }

    std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> Configuration()
    {
        return proxy_.getProperty("Configuration").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath CryptoBackingDevice()
    {
        return proxy_.getProperty("CryptoBackingDevice").onInterface(INTERFACE_NAME);
    }

    bool HintPartitionable()
    {
        return proxy_.getProperty("HintPartitionable").onInterface(INTERFACE_NAME);
    }

    bool HintSystem()
    {
        return proxy_.getProperty("HintSystem").onInterface(INTERFACE_NAME);
    }

    bool HintIgnore()
    {
        return proxy_.getProperty("HintIgnore").onInterface(INTERFACE_NAME);
    }

    bool HintAuto()
    {
        return proxy_.getProperty("HintAuto").onInterface(INTERFACE_NAME);
    }

    std::string HintName()
    {
        return proxy_.getProperty("HintName").onInterface(INTERFACE_NAME);
    }

    std::string HintIconName()
    {
        return proxy_.getProperty("HintIconName").onInterface(INTERFACE_NAME);
    }

    std::string HintSymbolicIconName()
    {
        return proxy_.getProperty("HintSymbolicIconName").onInterface(INTERFACE_NAME);
    }

    std::vector<std::string> UserspaceMountOptions()
    {
        return proxy_.getProperty("UserspaceMountOptions").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class PartitionTable_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.PartitionTable";

protected:
    PartitionTable_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~PartitionTable_proxy() = default;

public:
    sdbus::ObjectPath CreatePartition(const uint64_t& offset, const uint64_t& size, const std::string& type, const std::string& name, const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::ObjectPath result;
        proxy_.callMethod("CreatePartition").onInterface(INTERFACE_NAME).withArguments(offset, size, type, name, options).storeResultsTo(result);
        return result;
    }

    sdbus::ObjectPath CreatePartitionAndFormat(const uint64_t& offset, const uint64_t& size, const std::string& type, const std::string& name, const std::map<std::string, sdbus::Variant>& options, const std::string& format_type, const std::map<std::string, sdbus::Variant>& format_options)
    {
        sdbus::ObjectPath result;
        proxy_.callMethod("CreatePartitionAndFormat").onInterface(INTERFACE_NAME).withArguments(offset, size, type, name, options, format_type, format_options).storeResultsTo(result);
        return result;
    }

public:
    std::vector<sdbus::ObjectPath> Partitions()
    {
        return proxy_.getProperty("Partitions").onInterface(INTERFACE_NAME);
    }

    std::string Type()
    {
        return proxy_.getProperty("Type").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Partition_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Partition";

protected:
    Partition_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Partition_proxy() = default;

public:
    void SetType(const std::string& type, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetType").onInterface(INTERFACE_NAME).withArguments(type, options);
    }

    void SetName(const std::string& name, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetName").onInterface(INTERFACE_NAME).withArguments(name, options);
    }

    void SetUUID(const std::string& uuid, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetUUID").onInterface(INTERFACE_NAME).withArguments(uuid, options);
    }

    void SetFlags(const uint64_t& flags, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetFlags").onInterface(INTERFACE_NAME).withArguments(flags, options);
    }

    void Resize(const uint64_t& size, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Resize").onInterface(INTERFACE_NAME).withArguments(size, options);
    }

    void Delete(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Delete").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    uint32_t Number()
    {
        return proxy_.getProperty("Number").onInterface(INTERFACE_NAME);
    }

    std::string Type()
    {
        return proxy_.getProperty("Type").onInterface(INTERFACE_NAME);
    }

    uint64_t Flags()
    {
        return proxy_.getProperty("Flags").onInterface(INTERFACE_NAME);
    }

    uint64_t Offset()
    {
        return proxy_.getProperty("Offset").onInterface(INTERFACE_NAME);
    }

    uint64_t Size()
    {
        return proxy_.getProperty("Size").onInterface(INTERFACE_NAME);
    }

    std::string Name()
    {
        return proxy_.getProperty("Name").onInterface(INTERFACE_NAME);
    }

    std::string UUID()
    {
        return proxy_.getProperty("UUID").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath Table()
    {
        return proxy_.getProperty("Table").onInterface(INTERFACE_NAME);
    }

    bool IsContainer()
    {
        return proxy_.getProperty("IsContainer").onInterface(INTERFACE_NAME);
    }

    bool IsContained()
    {
        return proxy_.getProperty("IsContained").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Filesystem_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Filesystem";

protected:
    Filesystem_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Filesystem_proxy() = default;

public:
    void SetLabel(const std::string& label, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetLabel").onInterface(INTERFACE_NAME).withArguments(label, options);
    }

    void SetUUID(const std::string& uuid, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetUUID").onInterface(INTERFACE_NAME).withArguments(uuid, options);
    }

    std::string Mount(const std::map<std::string, sdbus::Variant>& options)
    {
        std::string result;
        proxy_.callMethod("Mount").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    void Unmount(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Unmount").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void Resize(const uint64_t& size, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Resize").onInterface(INTERFACE_NAME).withArguments(size, options);
    }

    bool Check(const std::map<std::string, sdbus::Variant>& options)
    {
        bool result;
        proxy_.callMethod("Check").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    bool Repair(const std::map<std::string, sdbus::Variant>& options)
    {
        bool result;
        proxy_.callMethod("Repair").onInterface(INTERFACE_NAME).withArguments(options).storeResultsTo(result);
        return result;
    }

    void TakeOwnership(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("TakeOwnership").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    std::vector<std::vector<uint8_t>> MountPoints()
    {
        return proxy_.getProperty("MountPoints").onInterface(INTERFACE_NAME);
    }

    uint64_t Size()
    {
        return proxy_.getProperty("Size").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Swapspace_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Swapspace";

protected:
    Swapspace_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Swapspace_proxy() = default;

public:
    void Start(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Start").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void Stop(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Stop").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void SetLabel(const std::string& label, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetLabel").onInterface(INTERFACE_NAME).withArguments(label, options);
    }

    void SetUUID(const std::string& uuid, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetUUID").onInterface(INTERFACE_NAME).withArguments(uuid, options);
    }

public:
    bool Active()
    {
        return proxy_.getProperty("Active").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Encrypted_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Encrypted";

protected:
    Encrypted_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Encrypted_proxy() = default;

public:
    sdbus::ObjectPath Unlock(const std::string& passphrase, const std::map<std::string, sdbus::Variant>& options)
    {
        sdbus::ObjectPath result;
        proxy_.callMethod("Unlock").onInterface(INTERFACE_NAME).withArguments(passphrase, options).storeResultsTo(result);
        return result;
    }

    void Lock(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Lock").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void ChangePassphrase(const std::string& passphrase, const std::string& new_passphrase, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("ChangePassphrase").onInterface(INTERFACE_NAME).withArguments(passphrase, new_passphrase, options);
    }

    void Resize(const uint64_t& size, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Resize").onInterface(INTERFACE_NAME).withArguments(size, options);
    }

public:
    std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> ChildConfiguration()
    {
        return proxy_.getProperty("ChildConfiguration").onInterface(INTERFACE_NAME);
    }

    std::string HintEncryptionType()
    {
        return proxy_.getProperty("HintEncryptionType").onInterface(INTERFACE_NAME);
    }

    uint64_t MetadataSize()
    {
        return proxy_.getProperty("MetadataSize").onInterface(INTERFACE_NAME);
    }

    sdbus::ObjectPath CleartextDevice()
    {
        return proxy_.getProperty("CleartextDevice").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Loop_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Loop";

protected:
    Loop_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~Loop_proxy() = default;

public:
    void Delete(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Delete").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void SetAutoclear(const bool& value, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetAutoclear").onInterface(INTERFACE_NAME).withArguments(value, options);
    }

public:
    std::vector<uint8_t> BackingFile()
    {
        return proxy_.getProperty("BackingFile").onInterface(INTERFACE_NAME);
    }

    bool Autoclear()
    {
        return proxy_.getProperty("Autoclear").onInterface(INTERFACE_NAME);
    }

    uint32_t SetupByUID()
    {
        return proxy_.getProperty("SetupByUID").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class MDRaid_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.MDRaid";

protected:
    MDRaid_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
    }

    ~MDRaid_proxy() = default;

public:
    void Start(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Start").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void Stop(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Stop").onInterface(INTERFACE_NAME).withArguments(options);
    }

    void RemoveDevice(const sdbus::ObjectPath& device, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("RemoveDevice").onInterface(INTERFACE_NAME).withArguments(device, options);
    }

    void AddDevice(const sdbus::ObjectPath& device, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("AddDevice").onInterface(INTERFACE_NAME).withArguments(device, options);
    }

    void SetBitmapLocation(const std::vector<uint8_t>& value, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("SetBitmapLocation").onInterface(INTERFACE_NAME).withArguments(value, options);
    }

    void RequestSyncAction(const std::string& sync_action, const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("RequestSyncAction").onInterface(INTERFACE_NAME).withArguments(sync_action, options);
    }

    void Delete(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Delete").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    std::string UUID()
    {
        return proxy_.getProperty("UUID").onInterface(INTERFACE_NAME);
    }

    std::string Name()
    {
        return proxy_.getProperty("Name").onInterface(INTERFACE_NAME);
    }

    std::string Level()
    {
        return proxy_.getProperty("Level").onInterface(INTERFACE_NAME);
    }

    uint32_t NumDevices()
    {
        return proxy_.getProperty("NumDevices").onInterface(INTERFACE_NAME);
    }

    uint64_t Size()
    {
        return proxy_.getProperty("Size").onInterface(INTERFACE_NAME);
    }

    std::string SyncAction()
    {
        return proxy_.getProperty("SyncAction").onInterface(INTERFACE_NAME);
    }

    double SyncCompleted()
    {
        return proxy_.getProperty("SyncCompleted").onInterface(INTERFACE_NAME);
    }

    uint64_t SyncRate()
    {
        return proxy_.getProperty("SyncRate").onInterface(INTERFACE_NAME);
    }

    uint64_t SyncRemainingTime()
    {
        return proxy_.getProperty("SyncRemainingTime").onInterface(INTERFACE_NAME);
    }

    uint32_t Degraded()
    {
        return proxy_.getProperty("Degraded").onInterface(INTERFACE_NAME);
    }

    std::vector<uint8_t> BitmapLocation()
    {
        return proxy_.getProperty("BitmapLocation").onInterface(INTERFACE_NAME);
    }

    uint64_t ChunkSize()
    {
        return proxy_.getProperty("ChunkSize").onInterface(INTERFACE_NAME);
    }

    std::vector<sdbus::Struct<sdbus::ObjectPath, int32_t, std::vector<std::string>, uint64_t, std::map<std::string, sdbus::Variant>>> ActiveDevices()
    {
        return proxy_.getProperty("ActiveDevices").onInterface(INTERFACE_NAME);
    }

    std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> ChildConfiguration()
    {
        return proxy_.getProperty("ChildConfiguration").onInterface(INTERFACE_NAME);
    }

    bool Running()
    {
        return proxy_.getProperty("Running").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Job_proxy
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Job";

protected:
    Job_proxy(sdbus::IProxy& proxy)
        : proxy_(proxy)
    {
        proxy_.uponSignal("Completed").onInterface(INTERFACE_NAME).call([this](const bool& success, const std::string& message){ this->onCompleted(success, message); });
    }

    ~Job_proxy() = default;

    virtual void onCompleted(const bool& success, const std::string& message) = 0;

public:
    void Cancel(const std::map<std::string, sdbus::Variant>& options)
    {
        proxy_.callMethod("Cancel").onInterface(INTERFACE_NAME).withArguments(options);
    }

public:
    std::string Operation()
    {
        return proxy_.getProperty("Operation").onInterface(INTERFACE_NAME);
    }

    double Progress()
    {
        return proxy_.getProperty("Progress").onInterface(INTERFACE_NAME);
    }

    bool ProgressValid()
    {
        return proxy_.getProperty("ProgressValid").onInterface(INTERFACE_NAME);
    }

    uint64_t Bytes()
    {
        return proxy_.getProperty("Bytes").onInterface(INTERFACE_NAME);
    }

    uint64_t Rate()
    {
        return proxy_.getProperty("Rate").onInterface(INTERFACE_NAME);
    }

    uint64_t StartTime()
    {
        return proxy_.getProperty("StartTime").onInterface(INTERFACE_NAME);
    }

    uint64_t ExpectedEndTime()
    {
        return proxy_.getProperty("ExpectedEndTime").onInterface(INTERFACE_NAME);
    }

    std::vector<sdbus::ObjectPath> Objects()
    {
        return proxy_.getProperty("Objects").onInterface(INTERFACE_NAME);
    }

    uint32_t StartedByUID()
    {
        return proxy_.getProperty("StartedByUID").onInterface(INTERFACE_NAME);
    }

    bool Cancelable()
    {
        return proxy_.getProperty("Cancelable").onInterface(INTERFACE_NAME);
    }

private:
    sdbus::IProxy& proxy_;
};

}}} // namespaces

#endif
