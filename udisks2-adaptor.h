
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp__udisks2_adaptor_h__adaptor__H__
#define __sdbuscpp__udisks2_adaptor_h__adaptor__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Manager_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Manager";

protected:
    Manager_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("CanFormat").onInterface(INTERFACE_NAME).withInputParamNames("type").withOutputParamNames("available").implementedAs([this](const std::string& type){ return this->CanFormat(type); });
        object_.registerMethod("CanResize").onInterface(INTERFACE_NAME).withInputParamNames("type").withOutputParamNames("available").implementedAs([this](const std::string& type){ return this->CanResize(type); });
        object_.registerMethod("CanCheck").onInterface(INTERFACE_NAME).withInputParamNames("type").withOutputParamNames("available").implementedAs([this](const std::string& type){ return this->CanCheck(type); });
        object_.registerMethod("CanRepair").onInterface(INTERFACE_NAME).withInputParamNames("type").withOutputParamNames("available").implementedAs([this](const std::string& type){ return this->CanRepair(type); });
        object_.registerMethod("LoopSetup").onInterface(INTERFACE_NAME).withInputParamNames("fd", "options").withOutputParamNames("resulting_device").implementedAs([this](const sdbus::UnixFd& fd, const std::map<std::string, sdbus::Variant>& options){ return this->LoopSetup(fd, options); });
        object_.registerMethod("MDRaidCreate").onInterface(INTERFACE_NAME).withInputParamNames("blocks", "level", "name", "chunk", "options").withOutputParamNames("resulting_array").implementedAs([this](const std::vector<sdbus::ObjectPath>& blocks, const std::string& level, const std::string& name, const uint64_t& chunk, const std::map<std::string, sdbus::Variant>& options){ return this->MDRaidCreate(blocks, level, name, chunk, options); });
        object_.registerMethod("EnableModules").onInterface(INTERFACE_NAME).withInputParamNames("enable").implementedAs([this](const bool& enable){ return this->EnableModules(enable); }).markAsDeprecated();
        object_.registerMethod("EnableModule").onInterface(INTERFACE_NAME).withInputParamNames("name", "enable").implementedAs([this](const std::string& name, const bool& enable){ return this->EnableModule(name, enable); });
        object_.registerMethod("GetBlockDevices").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("block_objects").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->GetBlockDevices(options); });
        object_.registerMethod("ResolveDevice").onInterface(INTERFACE_NAME).withInputParamNames("devspec", "options").withOutputParamNames("devices").implementedAs([this](const std::map<std::string, sdbus::Variant>& devspec, const std::map<std::string, sdbus::Variant>& options){ return this->ResolveDevice(devspec, options); });
        object_.registerProperty("Version").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Version(); });
        object_.registerProperty("SupportedFilesystems").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SupportedFilesystems(); });
        object_.registerProperty("SupportedEncryptionTypes").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SupportedEncryptionTypes(); });
        object_.registerProperty("DefaultEncryptionType").onInterface(INTERFACE_NAME).withGetter([this](){ return this->DefaultEncryptionType(); });
    }

    ~Manager_adaptor() = default;

private:
    virtual sdbus::Struct<bool, std::string> CanFormat(const std::string& type) = 0;
    virtual sdbus::Struct<bool, uint64_t, std::string> CanResize(const std::string& type) = 0;
    virtual sdbus::Struct<bool, std::string> CanCheck(const std::string& type) = 0;
    virtual sdbus::Struct<bool, std::string> CanRepair(const std::string& type) = 0;
    virtual sdbus::ObjectPath LoopSetup(const sdbus::UnixFd& fd, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual sdbus::ObjectPath MDRaidCreate(const std::vector<sdbus::ObjectPath>& blocks, const std::string& level, const std::string& name, const uint64_t& chunk, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void EnableModules(const bool& enable) = 0;
    virtual void EnableModule(const std::string& name, const bool& enable) = 0;
    virtual std::vector<sdbus::ObjectPath> GetBlockDevices(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual std::vector<sdbus::ObjectPath> ResolveDevice(const std::map<std::string, sdbus::Variant>& devspec, const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::string Version() = 0;
    virtual std::vector<std::string> SupportedFilesystems() = 0;
    virtual std::vector<std::string> SupportedEncryptionTypes() = 0;
    virtual std::string DefaultEncryptionType() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace Manager {

class NVMe_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Manager.NVMe";

protected:
    NVMe_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("SetHostNQN").onInterface(INTERFACE_NAME).withInputParamNames("hostnqn", "options").implementedAs([this](const std::vector<uint8_t>& hostnqn, const std::map<std::string, sdbus::Variant>& options){ return this->SetHostNQN(hostnqn, options); });
        object_.registerMethod("SetHostID").onInterface(INTERFACE_NAME).withInputParamNames("hostid", "options").implementedAs([this](const std::vector<uint8_t>& hostid, const std::map<std::string, sdbus::Variant>& options){ return this->SetHostID(hostid, options); });
        object_.registerMethod("Connect").onInterface(INTERFACE_NAME).withInputParamNames("subsysnqn", "transport", "transport_addr", "options").withOutputParamNames("nvme_ctrl").implementedAs([this](const std::vector<uint8_t>& subsysnqn, const std::string& transport, const std::string& transport_addr, const std::map<std::string, sdbus::Variant>& options){ return this->Connect(subsysnqn, transport, transport_addr, options); });
        object_.registerProperty("HostNQN").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HostNQN(); });
        object_.registerProperty("HostID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HostID(); });
    }

    ~NVMe_adaptor() = default;

private:
    virtual void SetHostNQN(const std::vector<uint8_t>& hostnqn, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetHostID(const std::vector<uint8_t>& hostid, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual sdbus::ObjectPath Connect(const std::vector<uint8_t>& subsysnqn, const std::string& transport, const std::string& transport_addr, const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::vector<uint8_t> HostNQN() = 0;
    virtual std::vector<uint8_t> HostID() = 0;

private:
    sdbus::IObject& object_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Drive_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Drive";

protected:
    Drive_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Eject").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Eject(options); });
        object_.registerMethod("SetConfiguration").onInterface(INTERFACE_NAME).withInputParamNames("value", "options").implementedAs([this](const std::map<std::string, sdbus::Variant>& value, const std::map<std::string, sdbus::Variant>& options){ return this->SetConfiguration(value, options); });
        object_.registerMethod("PowerOff").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->PowerOff(options); });
        object_.registerProperty("Vendor").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Vendor(); });
        object_.registerProperty("Model").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Model(); });
        object_.registerProperty("Revision").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Revision(); });
        object_.registerProperty("Serial").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Serial(); });
        object_.registerProperty("WWN").onInterface(INTERFACE_NAME).withGetter([this](){ return this->WWN(); });
        object_.registerProperty("Id").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Id(); });
        object_.registerProperty("Configuration").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Configuration(); });
        object_.registerProperty("Media").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Media(); });
        object_.registerProperty("MediaCompatibility").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MediaCompatibility(); });
        object_.registerProperty("MediaRemovable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MediaRemovable(); });
        object_.registerProperty("MediaAvailable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MediaAvailable(); });
        object_.registerProperty("MediaChangeDetected").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MediaChangeDetected(); });
        object_.registerProperty("Size").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Size(); });
        object_.registerProperty("TimeDetected").onInterface(INTERFACE_NAME).withGetter([this](){ return this->TimeDetected(); });
        object_.registerProperty("TimeMediaDetected").onInterface(INTERFACE_NAME).withGetter([this](){ return this->TimeMediaDetected(); });
        object_.registerProperty("Optical").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Optical(); });
        object_.registerProperty("OpticalBlank").onInterface(INTERFACE_NAME).withGetter([this](){ return this->OpticalBlank(); });
        object_.registerProperty("OpticalNumTracks").onInterface(INTERFACE_NAME).withGetter([this](){ return this->OpticalNumTracks(); });
        object_.registerProperty("OpticalNumAudioTracks").onInterface(INTERFACE_NAME).withGetter([this](){ return this->OpticalNumAudioTracks(); });
        object_.registerProperty("OpticalNumDataTracks").onInterface(INTERFACE_NAME).withGetter([this](){ return this->OpticalNumDataTracks(); });
        object_.registerProperty("OpticalNumSessions").onInterface(INTERFACE_NAME).withGetter([this](){ return this->OpticalNumSessions(); });
        object_.registerProperty("RotationRate").onInterface(INTERFACE_NAME).withGetter([this](){ return this->RotationRate(); });
        object_.registerProperty("ConnectionBus").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ConnectionBus(); });
        object_.registerProperty("Seat").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Seat(); });
        object_.registerProperty("Removable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Removable(); });
        object_.registerProperty("Ejectable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Ejectable(); });
        object_.registerProperty("SortKey").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SortKey(); });
        object_.registerProperty("CanPowerOff").onInterface(INTERFACE_NAME).withGetter([this](){ return this->CanPowerOff(); });
        object_.registerProperty("SiblingId").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SiblingId(); });
    }

    ~Drive_adaptor() = default;

private:
    virtual void Eject(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetConfiguration(const std::map<std::string, sdbus::Variant>& value, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void PowerOff(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::string Vendor() = 0;
    virtual std::string Model() = 0;
    virtual std::string Revision() = 0;
    virtual std::string Serial() = 0;
    virtual std::string WWN() = 0;
    virtual std::string Id() = 0;
    virtual std::map<std::string, sdbus::Variant> Configuration() = 0;
    virtual std::string Media() = 0;
    virtual std::vector<std::string> MediaCompatibility() = 0;
    virtual bool MediaRemovable() = 0;
    virtual bool MediaAvailable() = 0;
    virtual bool MediaChangeDetected() = 0;
    virtual uint64_t Size() = 0;
    virtual uint64_t TimeDetected() = 0;
    virtual uint64_t TimeMediaDetected() = 0;
    virtual bool Optical() = 0;
    virtual bool OpticalBlank() = 0;
    virtual uint32_t OpticalNumTracks() = 0;
    virtual uint32_t OpticalNumAudioTracks() = 0;
    virtual uint32_t OpticalNumDataTracks() = 0;
    virtual uint32_t OpticalNumSessions() = 0;
    virtual int32_t RotationRate() = 0;
    virtual std::string ConnectionBus() = 0;
    virtual std::string Seat() = 0;
    virtual bool Removable() = 0;
    virtual bool Ejectable() = 0;
    virtual std::string SortKey() = 0;
    virtual bool CanPowerOff() = 0;
    virtual std::string SiblingId() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace Drive {

class Ata_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Drive.Ata";

protected:
    Ata_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("SmartUpdate").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->SmartUpdate(options); });
        object_.registerMethod("SmartGetAttributes").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("attributes").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->SmartGetAttributes(options); });
        object_.registerMethod("SmartSelftestStart").onInterface(INTERFACE_NAME).withInputParamNames("type", "options").implementedAs([this](const std::string& type, const std::map<std::string, sdbus::Variant>& options){ return this->SmartSelftestStart(type, options); });
        object_.registerMethod("SmartSelftestAbort").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->SmartSelftestAbort(options); });
        object_.registerMethod("SmartSetEnabled").onInterface(INTERFACE_NAME).withInputParamNames("value", "options").implementedAs([this](const bool& value, const std::map<std::string, sdbus::Variant>& options){ return this->SmartSetEnabled(value, options); });
        object_.registerMethod("PmGetState").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("state").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->PmGetState(options); });
        object_.registerMethod("PmStandby").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->PmStandby(options); });
        object_.registerMethod("PmWakeup").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->PmWakeup(options); });
        object_.registerMethod("SecurityEraseUnit").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->SecurityEraseUnit(options); });
        object_.registerProperty("SmartSupported").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartSupported(); });
        object_.registerProperty("SmartEnabled").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartEnabled(); });
        object_.registerProperty("SmartUpdated").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartUpdated(); });
        object_.registerProperty("SmartFailing").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartFailing(); });
        object_.registerProperty("SmartPowerOnSeconds").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartPowerOnSeconds(); });
        object_.registerProperty("SmartTemperature").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartTemperature(); });
        object_.registerProperty("SmartNumAttributesFailing").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartNumAttributesFailing(); });
        object_.registerProperty("SmartNumAttributesFailedInThePast").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartNumAttributesFailedInThePast(); });
        object_.registerProperty("SmartNumBadSectors").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartNumBadSectors(); });
        object_.registerProperty("SmartSelftestStatus").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartSelftestStatus(); });
        object_.registerProperty("SmartSelftestPercentRemaining").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartSelftestPercentRemaining(); });
        object_.registerProperty("PmSupported").onInterface(INTERFACE_NAME).withGetter([this](){ return this->PmSupported(); });
        object_.registerProperty("PmEnabled").onInterface(INTERFACE_NAME).withGetter([this](){ return this->PmEnabled(); });
        object_.registerProperty("ApmSupported").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ApmSupported(); });
        object_.registerProperty("ApmEnabled").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ApmEnabled(); });
        object_.registerProperty("AamSupported").onInterface(INTERFACE_NAME).withGetter([this](){ return this->AamSupported(); });
        object_.registerProperty("AamEnabled").onInterface(INTERFACE_NAME).withGetter([this](){ return this->AamEnabled(); });
        object_.registerProperty("AamVendorRecommendedValue").onInterface(INTERFACE_NAME).withGetter([this](){ return this->AamVendorRecommendedValue(); });
        object_.registerProperty("WriteCacheSupported").onInterface(INTERFACE_NAME).withGetter([this](){ return this->WriteCacheSupported(); });
        object_.registerProperty("WriteCacheEnabled").onInterface(INTERFACE_NAME).withGetter([this](){ return this->WriteCacheEnabled(); });
        object_.registerProperty("ReadLookaheadSupported").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ReadLookaheadSupported(); });
        object_.registerProperty("ReadLookaheadEnabled").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ReadLookaheadEnabled(); });
        object_.registerProperty("SecurityEraseUnitMinutes").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SecurityEraseUnitMinutes(); });
        object_.registerProperty("SecurityEnhancedEraseUnitMinutes").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SecurityEnhancedEraseUnitMinutes(); });
        object_.registerProperty("SecurityFrozen").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SecurityFrozen(); });
    }

    ~Ata_adaptor() = default;

private:
    virtual void SmartUpdate(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual std::vector<sdbus::Struct<uint8_t, std::string, uint16_t, int32_t, int32_t, int32_t, int64_t, int32_t, std::map<std::string, sdbus::Variant>>> SmartGetAttributes(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SmartSelftestStart(const std::string& type, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SmartSelftestAbort(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SmartSetEnabled(const bool& value, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual uint8_t PmGetState(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void PmStandby(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void PmWakeup(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SecurityEraseUnit(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual bool SmartSupported() = 0;
    virtual bool SmartEnabled() = 0;
    virtual uint64_t SmartUpdated() = 0;
    virtual bool SmartFailing() = 0;
    virtual uint64_t SmartPowerOnSeconds() = 0;
    virtual double SmartTemperature() = 0;
    virtual int32_t SmartNumAttributesFailing() = 0;
    virtual int32_t SmartNumAttributesFailedInThePast() = 0;
    virtual int64_t SmartNumBadSectors() = 0;
    virtual std::string SmartSelftestStatus() = 0;
    virtual int32_t SmartSelftestPercentRemaining() = 0;
    virtual bool PmSupported() = 0;
    virtual bool PmEnabled() = 0;
    virtual bool ApmSupported() = 0;
    virtual bool ApmEnabled() = 0;
    virtual bool AamSupported() = 0;
    virtual bool AamEnabled() = 0;
    virtual int32_t AamVendorRecommendedValue() = 0;
    virtual bool WriteCacheSupported() = 0;
    virtual bool WriteCacheEnabled() = 0;
    virtual bool ReadLookaheadSupported() = 0;
    virtual bool ReadLookaheadEnabled() = 0;
    virtual int32_t SecurityEraseUnitMinutes() = 0;
    virtual int32_t SecurityEnhancedEraseUnitMinutes() = 0;
    virtual bool SecurityFrozen() = 0;

private:
    sdbus::IObject& object_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace NVMe {

class Controller_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.NVMe.Controller";

protected:
    Controller_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("SmartUpdate").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->SmartUpdate(options); });
        object_.registerMethod("SmartGetAttributes").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("attributes").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->SmartGetAttributes(options); });
        object_.registerMethod("SmartSelftestStart").onInterface(INTERFACE_NAME).withInputParamNames("type", "options").implementedAs([this](const std::string& type, const std::map<std::string, sdbus::Variant>& options){ return this->SmartSelftestStart(type, options); });
        object_.registerMethod("SmartSelftestAbort").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->SmartSelftestAbort(options); });
        object_.registerMethod("SanitizeStart").onInterface(INTERFACE_NAME).withInputParamNames("action", "options").implementedAs([this](const std::string& action, const std::map<std::string, sdbus::Variant>& options){ return this->SanitizeStart(action, options); });
        object_.registerProperty("State").onInterface(INTERFACE_NAME).withGetter([this](){ return this->State(); });
        object_.registerProperty("ControllerID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ControllerID(); });
        object_.registerProperty("SubsystemNQN").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SubsystemNQN(); });
        object_.registerProperty("FGUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->FGUID(); });
        object_.registerProperty("NVMeRevision").onInterface(INTERFACE_NAME).withGetter([this](){ return this->NVMeRevision(); });
        object_.registerProperty("UnallocatedCapacity").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UnallocatedCapacity(); });
        object_.registerProperty("SmartUpdated").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartUpdated(); });
        object_.registerProperty("SmartCriticalWarning").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartCriticalWarning(); });
        object_.registerProperty("SmartPowerOnHours").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartPowerOnHours(); });
        object_.registerProperty("SmartTemperature").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartTemperature(); });
        object_.registerProperty("SmartSelftestStatus").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartSelftestStatus(); });
        object_.registerProperty("SmartSelftestPercentRemaining").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SmartSelftestPercentRemaining(); });
        object_.registerProperty("SanitizeStatus").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SanitizeStatus(); });
        object_.registerProperty("SanitizePercentRemaining").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SanitizePercentRemaining(); });
    }

    ~Controller_adaptor() = default;

private:
    virtual void SmartUpdate(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual std::map<std::string, sdbus::Variant> SmartGetAttributes(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SmartSelftestStart(const std::string& type, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SmartSelftestAbort(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SanitizeStart(const std::string& action, const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::string State() = 0;
    virtual uint16_t ControllerID() = 0;
    virtual std::vector<uint8_t> SubsystemNQN() = 0;
    virtual std::string FGUID() = 0;
    virtual std::string NVMeRevision() = 0;
    virtual uint64_t UnallocatedCapacity() = 0;
    virtual uint64_t SmartUpdated() = 0;
    virtual std::vector<std::string> SmartCriticalWarning() = 0;
    virtual uint64_t SmartPowerOnHours() = 0;
    virtual uint16_t SmartTemperature() = 0;
    virtual std::string SmartSelftestStatus() = 0;
    virtual int32_t SmartSelftestPercentRemaining() = 0;
    virtual std::string SanitizeStatus() = 0;
    virtual int32_t SanitizePercentRemaining() = 0;

private:
    sdbus::IObject& object_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace NVMe {

class Namespace_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.NVMe.Namespace";

protected:
    Namespace_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("FormatNamespace").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->FormatNamespace(options); });
        object_.registerProperty("NSID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->NSID(); });
        object_.registerProperty("NGUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->NGUID(); });
        object_.registerProperty("EUI64").onInterface(INTERFACE_NAME).withGetter([this](){ return this->EUI64(); });
        object_.registerProperty("UUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UUID(); });
        object_.registerProperty("WWN").onInterface(INTERFACE_NAME).withGetter([this](){ return this->WWN(); });
        object_.registerProperty("LBAFormats").onInterface(INTERFACE_NAME).withGetter([this](){ return this->LBAFormats(); });
        object_.registerProperty("FormattedLBASize").onInterface(INTERFACE_NAME).withGetter([this](){ return this->FormattedLBASize(); });
        object_.registerProperty("NamespaceSize").onInterface(INTERFACE_NAME).withGetter([this](){ return this->NamespaceSize(); });
        object_.registerProperty("NamespaceCapacity").onInterface(INTERFACE_NAME).withGetter([this](){ return this->NamespaceCapacity(); });
        object_.registerProperty("NamespaceUtilization").onInterface(INTERFACE_NAME).withGetter([this](){ return this->NamespaceUtilization(); });
        object_.registerProperty("FormatPercentRemaining").onInterface(INTERFACE_NAME).withGetter([this](){ return this->FormatPercentRemaining(); });
    }

    ~Namespace_adaptor() = default;

private:
    virtual void FormatNamespace(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual uint32_t NSID() = 0;
    virtual std::string NGUID() = 0;
    virtual std::string EUI64() = 0;
    virtual std::string UUID() = 0;
    virtual std::string WWN() = 0;
    virtual std::vector<sdbus::Struct<uint16_t, uint16_t, uint8_t>> LBAFormats() = 0;
    virtual sdbus::Struct<uint16_t, uint16_t, uint8_t> FormattedLBASize() = 0;
    virtual uint64_t NamespaceSize() = 0;
    virtual uint64_t NamespaceCapacity() = 0;
    virtual uint64_t NamespaceUtilization() = 0;
    virtual int32_t FormatPercentRemaining() = 0;

private:
    sdbus::IObject& object_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {
namespace NVMe {

class Fabrics_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.NVMe.Fabrics";

protected:
    Fabrics_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Disconnect").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Disconnect(options); });
        object_.registerProperty("HostNQN").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HostNQN(); });
        object_.registerProperty("HostID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HostID(); });
        object_.registerProperty("Transport").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Transport(); });
        object_.registerProperty("TransportAddress").onInterface(INTERFACE_NAME).withGetter([this](){ return this->TransportAddress(); });
    }

    ~Fabrics_adaptor() = default;

private:
    virtual void Disconnect(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::vector<uint8_t> HostNQN() = 0;
    virtual std::vector<uint8_t> HostID() = 0;
    virtual std::string Transport() = 0;
    virtual std::vector<uint8_t> TransportAddress() = 0;

private:
    sdbus::IObject& object_;
};

}}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Block_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Block";

protected:
    Block_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("AddConfigurationItem").onInterface(INTERFACE_NAME).withInputParamNames("item", "options").implementedAs([this](const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& item, const std::map<std::string, sdbus::Variant>& options){ return this->AddConfigurationItem(item, options); });
        object_.registerMethod("RemoveConfigurationItem").onInterface(INTERFACE_NAME).withInputParamNames("item", "options").implementedAs([this](const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& item, const std::map<std::string, sdbus::Variant>& options){ return this->RemoveConfigurationItem(item, options); });
        object_.registerMethod("UpdateConfigurationItem").onInterface(INTERFACE_NAME).withInputParamNames("old_item", "new_item", "options").implementedAs([this](const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& old_item, const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& new_item, const std::map<std::string, sdbus::Variant>& options){ return this->UpdateConfigurationItem(old_item, new_item, options); });
        object_.registerMethod("GetSecretConfiguration").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("configuration").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->GetSecretConfiguration(options); });
        object_.registerMethod("Format").onInterface(INTERFACE_NAME).withInputParamNames("type", "options").implementedAs([this](const std::string& type, const std::map<std::string, sdbus::Variant>& options){ return this->Format(type, options); });
        object_.registerMethod("OpenForBackup").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("fd").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->OpenForBackup(options); });
        object_.registerMethod("OpenForRestore").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("fd").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->OpenForRestore(options); });
        object_.registerMethod("OpenForBenchmark").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("fd").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->OpenForBenchmark(options); });
        object_.registerMethod("OpenDevice").onInterface(INTERFACE_NAME).withInputParamNames("mode", "options").withOutputParamNames("fd").implementedAs([this](const std::string& mode, const std::map<std::string, sdbus::Variant>& options){ return this->OpenDevice(mode, options); });
        object_.registerMethod("Rescan").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Rescan(options); });
        object_.registerProperty("Device").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Device(); });
        object_.registerProperty("PreferredDevice").onInterface(INTERFACE_NAME).withGetter([this](){ return this->PreferredDevice(); });
        object_.registerProperty("Symlinks").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Symlinks(); });
        object_.registerProperty("DeviceNumber").onInterface(INTERFACE_NAME).withGetter([this](){ return this->DeviceNumber(); });
        object_.registerProperty("Id").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Id(); });
        object_.registerProperty("Size").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Size(); });
        object_.registerProperty("ReadOnly").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ReadOnly(); });
        object_.registerProperty("Drive").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Drive(); });
        object_.registerProperty("MDRaid").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MDRaid(); });
        object_.registerProperty("MDRaidMember").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MDRaidMember(); });
        object_.registerProperty("IdUsage").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IdUsage(); });
        object_.registerProperty("IdType").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IdType(); });
        object_.registerProperty("IdVersion").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IdVersion(); });
        object_.registerProperty("IdLabel").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IdLabel(); });
        object_.registerProperty("IdUUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IdUUID(); });
        object_.registerProperty("Configuration").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Configuration(); });
        object_.registerProperty("CryptoBackingDevice").onInterface(INTERFACE_NAME).withGetter([this](){ return this->CryptoBackingDevice(); });
        object_.registerProperty("HintPartitionable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintPartitionable(); });
        object_.registerProperty("HintSystem").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintSystem(); });
        object_.registerProperty("HintIgnore").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintIgnore(); });
        object_.registerProperty("HintAuto").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintAuto(); });
        object_.registerProperty("HintName").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintName(); });
        object_.registerProperty("HintIconName").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintIconName(); });
        object_.registerProperty("HintSymbolicIconName").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintSymbolicIconName(); });
        object_.registerProperty("UserspaceMountOptions").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UserspaceMountOptions(); });
    }

    ~Block_adaptor() = default;

private:
    virtual void AddConfigurationItem(const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& item, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void RemoveConfigurationItem(const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& item, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void UpdateConfigurationItem(const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& old_item, const sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>& new_item, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> GetSecretConfiguration(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Format(const std::string& type, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual sdbus::UnixFd OpenForBackup(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual sdbus::UnixFd OpenForRestore(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual sdbus::UnixFd OpenForBenchmark(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual sdbus::UnixFd OpenDevice(const std::string& mode, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Rescan(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::vector<uint8_t> Device() = 0;
    virtual std::vector<uint8_t> PreferredDevice() = 0;
    virtual std::vector<std::vector<uint8_t>> Symlinks() = 0;
    virtual uint64_t DeviceNumber() = 0;
    virtual std::string Id() = 0;
    virtual uint64_t Size() = 0;
    virtual bool ReadOnly() = 0;
    virtual sdbus::ObjectPath Drive() = 0;
    virtual sdbus::ObjectPath MDRaid() = 0;
    virtual sdbus::ObjectPath MDRaidMember() = 0;
    virtual std::string IdUsage() = 0;
    virtual std::string IdType() = 0;
    virtual std::string IdVersion() = 0;
    virtual std::string IdLabel() = 0;
    virtual std::string IdUUID() = 0;
    virtual std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> Configuration() = 0;
    virtual sdbus::ObjectPath CryptoBackingDevice() = 0;
    virtual bool HintPartitionable() = 0;
    virtual bool HintSystem() = 0;
    virtual bool HintIgnore() = 0;
    virtual bool HintAuto() = 0;
    virtual std::string HintName() = 0;
    virtual std::string HintIconName() = 0;
    virtual std::string HintSymbolicIconName() = 0;
    virtual std::vector<std::string> UserspaceMountOptions() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class PartitionTable_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.PartitionTable";

protected:
    PartitionTable_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("CreatePartition").onInterface(INTERFACE_NAME).withInputParamNames("offset", "size", "type", "name", "options").withOutputParamNames("created_partition").implementedAs([this](const uint64_t& offset, const uint64_t& size, const std::string& type, const std::string& name, const std::map<std::string, sdbus::Variant>& options){ return this->CreatePartition(offset, size, type, name, options); });
        object_.registerMethod("CreatePartitionAndFormat").onInterface(INTERFACE_NAME).withInputParamNames("offset", "size", "type", "name", "options", "format_type", "format_options").withOutputParamNames("created_partition").implementedAs([this](const uint64_t& offset, const uint64_t& size, const std::string& type, const std::string& name, const std::map<std::string, sdbus::Variant>& options, const std::string& format_type, const std::map<std::string, sdbus::Variant>& format_options){ return this->CreatePartitionAndFormat(offset, size, type, name, options, format_type, format_options); });
        object_.registerProperty("Partitions").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Partitions(); });
        object_.registerProperty("Type").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Type(); });
    }

    ~PartitionTable_adaptor() = default;

private:
    virtual sdbus::ObjectPath CreatePartition(const uint64_t& offset, const uint64_t& size, const std::string& type, const std::string& name, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual sdbus::ObjectPath CreatePartitionAndFormat(const uint64_t& offset, const uint64_t& size, const std::string& type, const std::string& name, const std::map<std::string, sdbus::Variant>& options, const std::string& format_type, const std::map<std::string, sdbus::Variant>& format_options) = 0;

private:
    virtual std::vector<sdbus::ObjectPath> Partitions() = 0;
    virtual std::string Type() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Partition_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Partition";

protected:
    Partition_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("SetType").onInterface(INTERFACE_NAME).withInputParamNames("type", "options").implementedAs([this](const std::string& type, const std::map<std::string, sdbus::Variant>& options){ return this->SetType(type, options); });
        object_.registerMethod("SetName").onInterface(INTERFACE_NAME).withInputParamNames("name", "options").implementedAs([this](const std::string& name, const std::map<std::string, sdbus::Variant>& options){ return this->SetName(name, options); });
        object_.registerMethod("SetUUID").onInterface(INTERFACE_NAME).withInputParamNames("uuid", "options").implementedAs([this](const std::string& uuid, const std::map<std::string, sdbus::Variant>& options){ return this->SetUUID(uuid, options); });
        object_.registerMethod("SetFlags").onInterface(INTERFACE_NAME).withInputParamNames("flags", "options").implementedAs([this](const uint64_t& flags, const std::map<std::string, sdbus::Variant>& options){ return this->SetFlags(flags, options); });
        object_.registerMethod("Resize").onInterface(INTERFACE_NAME).withInputParamNames("size", "options").implementedAs([this](const uint64_t& size, const std::map<std::string, sdbus::Variant>& options){ return this->Resize(size, options); });
        object_.registerMethod("Delete").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Delete(options); });
        object_.registerProperty("Number").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Number(); });
        object_.registerProperty("Type").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Type(); });
        object_.registerProperty("Flags").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Flags(); });
        object_.registerProperty("Offset").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Offset(); });
        object_.registerProperty("Size").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Size(); });
        object_.registerProperty("Name").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Name(); });
        object_.registerProperty("UUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UUID(); });
        object_.registerProperty("Table").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Table(); });
        object_.registerProperty("IsContainer").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IsContainer(); });
        object_.registerProperty("IsContained").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IsContained(); });
    }

    ~Partition_adaptor() = default;

private:
    virtual void SetType(const std::string& type, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetName(const std::string& name, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetUUID(const std::string& uuid, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetFlags(const uint64_t& flags, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Resize(const uint64_t& size, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Delete(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual uint32_t Number() = 0;
    virtual std::string Type() = 0;
    virtual uint64_t Flags() = 0;
    virtual uint64_t Offset() = 0;
    virtual uint64_t Size() = 0;
    virtual std::string Name() = 0;
    virtual std::string UUID() = 0;
    virtual sdbus::ObjectPath Table() = 0;
    virtual bool IsContainer() = 0;
    virtual bool IsContained() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Filesystem_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Filesystem";

protected:
    Filesystem_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("SetLabel").onInterface(INTERFACE_NAME).withInputParamNames("label", "options").implementedAs([this](const std::string& label, const std::map<std::string, sdbus::Variant>& options){ return this->SetLabel(label, options); });
        object_.registerMethod("SetUUID").onInterface(INTERFACE_NAME).withInputParamNames("uuid", "options").implementedAs([this](const std::string& uuid, const std::map<std::string, sdbus::Variant>& options){ return this->SetUUID(uuid, options); });
        object_.registerMethod("Mount").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("mount_path").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Mount(options); });
        object_.registerMethod("Unmount").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Unmount(options); });
        object_.registerMethod("Resize").onInterface(INTERFACE_NAME).withInputParamNames("size", "options").implementedAs([this](const uint64_t& size, const std::map<std::string, sdbus::Variant>& options){ return this->Resize(size, options); });
        object_.registerMethod("Check").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("consistent").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Check(options); });
        object_.registerMethod("Repair").onInterface(INTERFACE_NAME).withInputParamNames("options").withOutputParamNames("repaired").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Repair(options); });
        object_.registerMethod("TakeOwnership").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->TakeOwnership(options); });
        object_.registerProperty("MountPoints").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MountPoints(); });
        object_.registerProperty("Size").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Size(); });
    }

    ~Filesystem_adaptor() = default;

private:
    virtual void SetLabel(const std::string& label, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetUUID(const std::string& uuid, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual std::string Mount(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Unmount(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Resize(const uint64_t& size, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual bool Check(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual bool Repair(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void TakeOwnership(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::vector<std::vector<uint8_t>> MountPoints() = 0;
    virtual uint64_t Size() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Swapspace_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Swapspace";

protected:
    Swapspace_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Start").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Start(options); });
        object_.registerMethod("Stop").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Stop(options); });
        object_.registerMethod("SetLabel").onInterface(INTERFACE_NAME).withInputParamNames("label", "options").implementedAs([this](const std::string& label, const std::map<std::string, sdbus::Variant>& options){ return this->SetLabel(label, options); });
        object_.registerMethod("SetUUID").onInterface(INTERFACE_NAME).withInputParamNames("uuid", "options").implementedAs([this](const std::string& uuid, const std::map<std::string, sdbus::Variant>& options){ return this->SetUUID(uuid, options); });
        object_.registerProperty("Active").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Active(); });
    }

    ~Swapspace_adaptor() = default;

private:
    virtual void Start(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Stop(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetLabel(const std::string& label, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetUUID(const std::string& uuid, const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual bool Active() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Encrypted_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Encrypted";

protected:
    Encrypted_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Unlock").onInterface(INTERFACE_NAME).withInputParamNames("passphrase", "options").withOutputParamNames("cleartext_device").implementedAs([this](const std::string& passphrase, const std::map<std::string, sdbus::Variant>& options){ return this->Unlock(passphrase, options); });
        object_.registerMethod("Lock").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Lock(options); });
        object_.registerMethod("ChangePassphrase").onInterface(INTERFACE_NAME).withInputParamNames("passphrase", "new_passphrase", "options").implementedAs([this](const std::string& passphrase, const std::string& new_passphrase, const std::map<std::string, sdbus::Variant>& options){ return this->ChangePassphrase(passphrase, new_passphrase, options); });
        object_.registerMethod("Resize").onInterface(INTERFACE_NAME).withInputParamNames("size", "options").implementedAs([this](const uint64_t& size, const std::map<std::string, sdbus::Variant>& options){ return this->Resize(size, options); });
        object_.registerProperty("ChildConfiguration").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ChildConfiguration(); });
        object_.registerProperty("HintEncryptionType").onInterface(INTERFACE_NAME).withGetter([this](){ return this->HintEncryptionType(); });
        object_.registerProperty("MetadataSize").onInterface(INTERFACE_NAME).withGetter([this](){ return this->MetadataSize(); });
        object_.registerProperty("CleartextDevice").onInterface(INTERFACE_NAME).withGetter([this](){ return this->CleartextDevice(); });
    }

    ~Encrypted_adaptor() = default;

private:
    virtual sdbus::ObjectPath Unlock(const std::string& passphrase, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Lock(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void ChangePassphrase(const std::string& passphrase, const std::string& new_passphrase, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Resize(const uint64_t& size, const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> ChildConfiguration() = 0;
    virtual std::string HintEncryptionType() = 0;
    virtual uint64_t MetadataSize() = 0;
    virtual sdbus::ObjectPath CleartextDevice() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Loop_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Loop";

protected:
    Loop_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Delete").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Delete(options); });
        object_.registerMethod("SetAutoclear").onInterface(INTERFACE_NAME).withInputParamNames("value", "options").implementedAs([this](const bool& value, const std::map<std::string, sdbus::Variant>& options){ return this->SetAutoclear(value, options); });
        object_.registerProperty("BackingFile").onInterface(INTERFACE_NAME).withGetter([this](){ return this->BackingFile(); });
        object_.registerProperty("Autoclear").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Autoclear(); });
        object_.registerProperty("SetupByUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SetupByUID(); });
    }

    ~Loop_adaptor() = default;

private:
    virtual void Delete(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetAutoclear(const bool& value, const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::vector<uint8_t> BackingFile() = 0;
    virtual bool Autoclear() = 0;
    virtual uint32_t SetupByUID() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class MDRaid_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.MDRaid";

protected:
    MDRaid_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Start").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Start(options); });
        object_.registerMethod("Stop").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Stop(options); });
        object_.registerMethod("RemoveDevice").onInterface(INTERFACE_NAME).withInputParamNames("device", "options").implementedAs([this](const sdbus::ObjectPath& device, const std::map<std::string, sdbus::Variant>& options){ return this->RemoveDevice(device, options); });
        object_.registerMethod("AddDevice").onInterface(INTERFACE_NAME).withInputParamNames("device", "options").implementedAs([this](const sdbus::ObjectPath& device, const std::map<std::string, sdbus::Variant>& options){ return this->AddDevice(device, options); });
        object_.registerMethod("SetBitmapLocation").onInterface(INTERFACE_NAME).withInputParamNames("value", "options").implementedAs([this](const std::vector<uint8_t>& value, const std::map<std::string, sdbus::Variant>& options){ return this->SetBitmapLocation(value, options); });
        object_.registerMethod("RequestSyncAction").onInterface(INTERFACE_NAME).withInputParamNames("sync_action", "options").implementedAs([this](const std::string& sync_action, const std::map<std::string, sdbus::Variant>& options){ return this->RequestSyncAction(sync_action, options); });
        object_.registerMethod("Delete").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Delete(options); });
        object_.registerProperty("UUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UUID(); });
        object_.registerProperty("Name").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Name(); });
        object_.registerProperty("Level").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Level(); });
        object_.registerProperty("NumDevices").onInterface(INTERFACE_NAME).withGetter([this](){ return this->NumDevices(); });
        object_.registerProperty("Size").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Size(); });
        object_.registerProperty("SyncAction").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SyncAction(); });
        object_.registerProperty("SyncCompleted").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SyncCompleted(); });
        object_.registerProperty("SyncRate").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SyncRate(); });
        object_.registerProperty("SyncRemainingTime").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SyncRemainingTime(); });
        object_.registerProperty("Degraded").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Degraded(); });
        object_.registerProperty("BitmapLocation").onInterface(INTERFACE_NAME).withGetter([this](){ return this->BitmapLocation(); });
        object_.registerProperty("ChunkSize").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ChunkSize(); });
        object_.registerProperty("ActiveDevices").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ActiveDevices(); });
        object_.registerProperty("ChildConfiguration").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ChildConfiguration(); });
        object_.registerProperty("Running").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Running(); });
    }

    ~MDRaid_adaptor() = default;

private:
    virtual void Start(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Stop(const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void RemoveDevice(const sdbus::ObjectPath& device, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void AddDevice(const sdbus::ObjectPath& device, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void SetBitmapLocation(const std::vector<uint8_t>& value, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void RequestSyncAction(const std::string& sync_action, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void Delete(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::string UUID() = 0;
    virtual std::string Name() = 0;
    virtual std::string Level() = 0;
    virtual uint32_t NumDevices() = 0;
    virtual uint64_t Size() = 0;
    virtual std::string SyncAction() = 0;
    virtual double SyncCompleted() = 0;
    virtual uint64_t SyncRate() = 0;
    virtual uint64_t SyncRemainingTime() = 0;
    virtual uint32_t Degraded() = 0;
    virtual std::vector<uint8_t> BitmapLocation() = 0;
    virtual uint64_t ChunkSize() = 0;
    virtual std::vector<sdbus::Struct<sdbus::ObjectPath, int32_t, std::vector<std::string>, uint64_t, std::map<std::string, sdbus::Variant>>> ActiveDevices() = 0;
    virtual std::vector<sdbus::Struct<std::string, std::map<std::string, sdbus::Variant>>> ChildConfiguration() = 0;
    virtual bool Running() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace freedesktop {
namespace UDisks2 {

class Job_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.UDisks2.Job";

protected:
    Job_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Cancel").onInterface(INTERFACE_NAME).withInputParamNames("options").implementedAs([this](const std::map<std::string, sdbus::Variant>& options){ return this->Cancel(options); });
        object_.registerSignal("Completed").onInterface(INTERFACE_NAME).withParameters<bool, std::string>("success", "message");
        object_.registerProperty("Operation").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Operation(); });
        object_.registerProperty("Progress").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Progress(); });
        object_.registerProperty("ProgressValid").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ProgressValid(); });
        object_.registerProperty("Bytes").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Bytes(); });
        object_.registerProperty("Rate").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Rate(); });
        object_.registerProperty("StartTime").onInterface(INTERFACE_NAME).withGetter([this](){ return this->StartTime(); });
        object_.registerProperty("ExpectedEndTime").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ExpectedEndTime(); });
        object_.registerProperty("Objects").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Objects(); });
        object_.registerProperty("StartedByUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->StartedByUID(); });
        object_.registerProperty("Cancelable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Cancelable(); });
    }

    ~Job_adaptor() = default;

public:
    void emitCompleted(const bool& success, const std::string& message)
    {
        object_.emitSignal("Completed").onInterface(INTERFACE_NAME).withArguments(success, message);
    }

private:
    virtual void Cancel(const std::map<std::string, sdbus::Variant>& options) = 0;

private:
    virtual std::string Operation() = 0;
    virtual double Progress() = 0;
    virtual bool ProgressValid() = 0;
    virtual uint64_t Bytes() = 0;
    virtual uint64_t Rate() = 0;
    virtual uint64_t StartTime() = 0;
    virtual uint64_t ExpectedEndTime() = 0;
    virtual std::vector<sdbus::ObjectPath> Objects() = 0;
    virtual uint32_t StartedByUID() = 0;
    virtual bool Cancelable() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

#endif
